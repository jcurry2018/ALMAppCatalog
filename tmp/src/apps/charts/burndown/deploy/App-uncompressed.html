<!DOCTYPE html>
<html>
<head>
    <title>Release Burndown</title>

    <script type="text/javascript" src="/apps/x/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.DateMixin", {

        dateFormatters: [
            {key: "MMM", value: "%b"},
            {key: "MM", value: "%m"},
            {key: "dd", value: "%d"},
            {key: "yyyy", value: "%Y"}
        ],

        dateToStringDisplay: function (date) {
            return Ext.Date.format(date, 'm/d/Y');
        },

        dateToString: function (date) {
            return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
        },

        dateStringToObject: function (dateStr) {
            var finalIndex = dateStr.indexOf('T'),
                dateObj;

            if (finalIndex > -1) {
                dateStr = dateStr.slice(0, dateStr.indexOf('T'));
            }

            dateObj = this._splitDateParts(dateStr);

            return new Date(dateObj.year, dateObj.month, dateObj.day);
        },

        _splitDateParts: function (dateStr) {
            if (this._shouldSplitOnDash(dateStr)) {
                return this._objectFromYearFirstDate(dateStr.split('-'));
            }
            else {
                return this._objectFromMonthFirstDate(dateStr.split('/'));
            }
        },

        _objectFromYearFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[1] = (parseInt(dateArray[1], 10) - 1).toString();

            return {
                year: dateArray[0],
                month: dateArray[1],
                day: dateArray[2]
            };
        },

        _objectFromMonthFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[0] = (parseInt(dateArray[0], 10) - 1).toString();

            return {
                month: dateArray[0],
                day: dateArray[1],
                year: dateArray[2]
            };
        },

        _shouldSplitOnDash: function (dateStr) {
            return dateStr.split('-').length === 3;
        }

    });

}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.IntegrationHeaders", {

        keyConverters : {
            name : function() { return 'X-RallyIntegrationName'; },
            vendor : function() { return 'X-RallyIntegrationVendor'; },
            platform : function() { return 'X-RallyIntegrationPlatform'; },
            os : function() { return 'X-RallyIntegrationOS'; },
            version : function() { return 'X-RallyIntegrationVersion'; },
            library : function() { return 'X-RallyIntegrationLibrary'; }
        },

        constructor: function(config) {
            this.headers = {
                name : 'A2 Chart',
                vendor : 'Rally Software'
            };

            Ext.merge(this.headers, config.integrationHeaders || {});
            this.callParent(config);
        },
        withName : function(nm) {
            this.headers.name = nm || this.headers.name;
            return this;
        },
        withVendor : function(v) {
            this.headers.vendor = v || this.headers.vendor;
            return this;
        },
        withPlatform : function(newPlatform) {
            this.headers.platform = newPlatform || this.headers.platform;
            return this;
        },
        withVersion : function(newVersion) {
            this.headers.version = newVersion || this.headers.version;
            return this;
        },
        withOS : function(newOS) {
            this.headers.os = newOS || this.headers.os;
            return this;
        },
        withLibrary : function(newLibrary) {
            this.headers.library = newLibrary || this.headers.library;
            return this;
        },
        applyTo : function(config) {
            config.headers = config.headers || {};
            Ext.merge(config.headers, this.build());
            return config;
        },
        build : function() {
            var h = {};
            for (var k in this.headers) {
                if (this.headers.hasOwnProperty(k)) {
                    if (this.headers[k] === null) { continue; }
                    var key = this._keyConverter(k)(k);
                    h[key] = this.headers[k];
                }
            }
            return h;
        },
        _keyConverter: function(key) {
            if (this.keyConverters.hasOwnProperty(key)) {
                return this.keyConverters[key];
            } else {
                return function(x) {return x;};
            }
        }
    });
}());

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.RadioGroupSetting", {
        extend: "Ext.form.FieldContainer",

        config: {
            settingName: undefined
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent(arguments);
        },

        getSetting: function() {
            return this.settingsParent.app.getSetting(this.settingName);
        },

        setRadioValue: function (cmp) {
            this.setRadioToCustomValue(cmp, this.getSetting());
        },

        setRadioToCustomValue: function (cmp, customValue) {
            var value = {};
            value[cmp.name] = customValue;
            cmp.setValue(value);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdisplaytypepicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartDisplayType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._getPicker());
        },

        _getPicker: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Line", name: this.settingName, inputValue: "line", checked: true },
                    { boxLabel: "Column", name: this.settingName, inputValue: "column" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.SettingsChangeMixin", {

        sendSettingsChange: function(artifact) {
            if (this.settingsParent) {
                this.settingsParent.sendSettingsChange(artifact, this);
            }
        },

        receiveSettingsChange: function(artifact) {

        }

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.DataTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdatatypepicker",

        mixins: [
            "Ext.form.field.Field",
            "Rally.apps.charts.settings.SettingsChangeMixin"
        ],

        config: {
            settingName: "chartAggregationType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._addRadioGroup());
        },

        _addRadioGroup: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Story Plan Estimate", name: this.settingName, inputValue: "storypoints", checked: true },
                    { boxLabel: "Story Count", name: this.settingName, inputValue: "storycount" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.TimeboxPicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.charttimeboxpicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartTimebox"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this._addRadioGroup();
        },

        _addRadioGroup: function () {
            this.add({
                xtype: "radiogroup",
                name: this.settingName,
                itemId: this.settingName,
                label: "Level",
                columns: [160, 100, 100],
                vertical: false,
                items: [
                    { boxLabel: "Release", name: this.settingName, inputValue: "release", checked: true },
                    { boxLabel: "Iteration", name: this.settingName, inputValue: "iteration" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                },
                config: {
                    cls: "levelchooser"
                }
            });
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownSettings", {
        requires: [
            "Rally.apps.charts.settings.ChartDisplayTypePicker",
            "Rally.apps.charts.settings.DataTypePicker",
            "Rally.apps.charts.settings.TimeboxPicker",
            "Rally.ui.CheckboxField"
        ],

        config: {
            app: undefined
        },
        
        constructor: function (config) {
            this.mergeConfig(config);
        },

        _buildSettingsComponent: function (type, label, name) {
            var self = this;

            var componentAdded = function (cmp) {
                this.settingsParent = this.settingsParent || self;
            };

            var settings = {
                xtype: type,
                label: label,
                listeners: {
                    added: componentAdded
                }
            };
            if (name) {
                settings.name = name;
                settings.cls = "settings-" + name;
            }
            return settings;
        },

        _isOnScopedDashboard: function() {
            return this.app.isOnScopedDashboard() && !!this.app.context.getTimeboxScope();
        },

        getFields: function() {
            var dataTypePicker = this._buildSettingsComponent("chartdatatypepicker", "Data Type"),
                displayPicker = this._buildSettingsComponent("chartdisplaytypepicker", "Chart Type"),
                timeboxPicker = this._buildSettingsComponent("charttimeboxpicker", "Level"),
                labelNameVisible = this._buildSettingsComponent("rallycheckboxfield", "Show Iteration Labels", 'showLabels');
            
            if(this._isOnScopedDashboard()) {
                return [dataTypePicker, displayPicker, labelNameVisible];
            } else {
                return [timeboxPicker, dataTypePicker, displayPicker, labelNameVisible];
            }
        }
        

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        defaultChartComponentConfig: function() {
            return {
                xtype: "rallychart",
                itemId: "burndownchart",

                aggregationErrorMessage: "No data to display. Check the data type setting for displaying data based on count versus plan estimate.",

                storeType: "Rally.data.lookback.SnapshotStore",
                storeConfig: {
                    find: {
                        "_TypeHierarchy": { '$in' : [ -51038, -51006 ] },
                        "Children": null
                    },
                    fetch: ["ScheduleState", "PlanEstimate", "ObjectId", "_ValidFrom", "_ValidTo"],
                    hydrate: ["ScheduleState"],
                    sort: {
                        "_ValidFrom": 1
                    },
                    compress: true,
                    useHttpPost: true
                },

                calculatorType: "Rally.apps.charts.burndown.BurnDownCalculator",
                calculatorConfig: {
                    timeZone: "GMT",
                    completedScheduleStateNames: ["Accepted", "Released"],
                    enableProjections: true

                    //chartAggregationType: ''
                },

                chartColors: ["#005eb8", "#8dc63f", "#666666", "#c0c0c0"],

                chartConfig: {
                    chart: {
                        zoomType: "xy"
                    },
                    xAxis: {
                        categories: [],
                        tickmarkPlacement: "on",
                        tickInterval: 7,
                        title: {
                            text: "Days",
                            margin: 12
                        },
                        maxPadding: 0.25,
                        labels: {
                            x: 0,
                            y: 20,
                            overflow: "justify"
                        }
                    },
                    yAxis: [],
                    tooltip: {
                        formatter: function () {
                            var floatValue = parseFloat(this.y),
                                value = this.y;

                            if (!isNaN(floatValue)) {
                                value = Math.floor(floatValue * 100) / 100;
                            }

                            return "" + this.x + "<br />" + this.series.name + ": " + value;
                        }
                    },
                    plotOptions: {
                        series: {
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                }
                            },
                            connectNulls: true
                        },
                        column: {
                            pointPadding: 0,
                            borderWidth: 0,
                            stacking: null,
                            shadow: false
                        }
                    }
                }
            };

        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.BurnDownApp', {
        extend: 'Rally.app.TimeboxScopedApp',

        settingsScope: 'workspace',

        requires: [
            'Rally.apps.charts.burndown.BurnDownSettings',
            'Rally.data.wsapi.Store',
            'Rally.util.Help',
            'Rally.ui.combobox.IterationComboBox',
            'Rally.ui.combobox.ReleaseComboBox',
            'Rally.apps.charts.IntegrationHeaders',
            'Rally.apps.charts.burndown.BurnDownChart'
        ],

        mixins: [
            'Rally.apps.charts.DateMixin'
        ],

        cls: 'burndown-app',

        items: [
            {
                xtype: 'container',
                itemId: 'header',
                cls: 'header'
            }
        ],

        help: {
            id: 278
        },

        scopeObject: undefined,

        customScheduleStates: ['Accepted'],	// a reasonable default

        config: {
            defaultSettings: {
                showLabels: true,
                chartAggregationType: undefined,
                chartDisplayType: undefined,
                chartTimebox: undefined,
                title: ''
            }
        },

        chartComponentConfig: undefined,

        getSettingsFields: function () {
            this.chartSettings = this.chartSettings || Ext.create('Rally.apps.charts.burndown.BurnDownSettings', {
                app: this
            });

            return this.chartSettings.getFields();
        },

        onScopeChange: function (scope) {
            if (!this.ignoreOnScopeChange) {
                this._rebuildChartForScope(scope.getRecord().get('_ref'));
            }
        },

        launch: function () {
            if (this._settingsInvalid()) {
                if (this.owner) {
                    this.owner.showSettings();
                    return;
                }
            }

            this.chartComponentConfig = Ext.create('Rally.apps.charts.burndown.BurnDownChart', this).defaultChartComponentConfig();

            Ext.create('Rally.apps.charts.IntegrationHeaders',this).applyTo(this.chartComponentConfig.storeConfig);

            this._addHelpComponent();
            this._loadUserStoryModel();
            this._saveScopeType();
            this.callParent(arguments);

            if (!this.isOnScopedDashboard()) {
                this.ignoreOnScopeChange = true;
                this._getScopePicker().on('ready', this._loadScopePreference, this, {single: true});
            }
        },

        _addHelpComponent: function () {
            this.down('#header').add(this._buildHelpComponent());
        },

        _buildHelpComponent: function () {
            return Ext.create('Ext.Component', {
                renderTpl: Rally.util.Help.getIcon({
                    cls: Rally.util.Test.toBrowserTestCssClass(this.help.cls),
                    id: this.help.id
                })
            });
        },

        _rebuildChartForScope: function(scopeRef) {
            this._destroyChart();

            this._saveScopePreference(scopeRef);
            this._loadScopeObject(scopeRef);
        },

        _destroyChart: function () {
            this.remove('burndownchart');
        },

        _saveScopePreference: function (scopeRef) {
            if (!this.isOnScopedDashboard()) {
                var settings = {};
                settings[this._getScopeType()] = scopeRef;

                Rally.data.PreferenceManager.update({
                    appID: this.getContext().get('appID'),
                    settings: settings,
                    scope: this
                });
            }
        },

        _loadScopePreference: function (picker) {
            Rally.data.PreferenceManager.load({
                appID: this.getContext().get('appID'),
                success: function (preferences) {
                    var scopeRef = preferences[this._getScopeType()];
                    if (!scopeRef || scopeRef === 'undefined') {
                        var pickerRecord = picker.getRecord();
                        if (pickerRecord) {
                            scopeRef = pickerRecord.get('_ref');
                            this._saveScopePreference(scopeRef);
                        }
                    }
                    this.ignoreOnScopeChange = false;

                    if (scopeRef && scopeRef !== 'undefined') {
                        this._setScopeValue(scopeRef);
                        scopeRef = this._getScopePicker().getValue();
                        if (scopeRef) {
                            this._rebuildChartForScope(scopeRef);
                        }
                    }
                },
                scope: this
            });
        },

        _setScopeValue: function (scopeRef) {
            this._getScopePicker().setValue(scopeRef);
        },

        _loadTimeboxes: function() {
            Ext.create('Rally.data.wsapi.Store', {
                model: this.scopeObject._type,
                filters: [
                    {
                        property: 'Name',
                        operator: '=',
                        value: this.scopeObject.Name
                    },
                    {
                        property: this._getScopeObjectStartDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: this._getScopeObjectEndDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: this.getContext().getDataContext(),
                fetch: ['ObjectID'],
                limit: Infinity,
                autoLoad: true,
                listeners: {
                    load: function (store, records) {
                        this._getTimeboxesInScope(store, records);
                    },
                    scope: this
                }
            });
        },

        _onScopeObjectLoaded: function (record) {
            this._setScopeFromData(record);

            this._updateChartTitle();
            this._updateYAxis();

            this._addDateBounds();
            this._addAggregationTypeToCalculator();
            this._updateCompletedScheduleStates();
            this._loadTimeboxes();
        },

        _renderChartBasedOnType: function () {
            if (this._getScopeType() === 'release') {
                this._fetchIterations();
            } else {
                this._addChart();
            }
        },

        _setScopeFromData: function (record) {
            this.scopeObject = record.data;
        },

        _getTimeboxesInScope: function (store, records) {
            var storeConfig = this.chartComponentConfig.storeConfig;
            var type = Ext.String.capitalize(this._getScopeType());
            var oids = [];
            var i;

            this.timeboxes = store.getItems();
            this._clearStoreConfig(storeConfig);

            for (i = 0; i < this.timeboxes.length; i++) {
                oids.push(this.timeboxes[i].ObjectID);
            }
            storeConfig.find[type] = { '$in' : oids };

            this._renderChartBasedOnType();

        },

        _onIterationsLoaded: function (store) {
            this.iterations = store.getItems();

            this._addChart();
            this.down('rallychart').on('snapshotsAggregated', this._addIterationLines, this);
        },

        _addDateBounds: function () {
            this._addDateBoundsToQuery();
            this._addDateBoundsToCalculator();
        },

        _addDateBoundsToQuery: function () {

        },

        _getNow: function() {
            return new Date();
        },

        _addDateBoundsToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            var endDate = this._getScopeObjectEndDate();
            var now = this._getNow();
            calcConfig.startDate = Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true);
            if(now > this._getScopeObjectStartDate() && now < this._getScopeObjectEndDate()) {
                endDate = now;
            }
            calcConfig.endDate = Rally.util.DateTime.toIsoString(endDate, true);
            // S53625: If the time-box has ended, disable the projection line
            if (now > this._getScopeObjectEndDate()) {
                calcConfig.enableProjections = false;
            } else {
                calcConfig.enableProjections = true;
            }
            // add scopeEndDate, which may or may not be the same as endDate
            calcConfig.scopeEndDate = this._getScopeObjectEndDate();
        },

        _addAggregationTypeToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.chartAggregationType = this.getSetting('chartAggregationType');
        },

        _updateCompletedScheduleStates: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.completedScheduleStateNames = this.customScheduleStates;
        },

        _loadScopeObject: function (scopeRef) {
            Rally.data.ModelFactory.getModel({
                type: this._getScopeType(),

                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: null
                },
                success: function(model) {
                    model.load(Rally.util.Ref.getOidFromRef(scopeRef), {
                        success: function(record) {
                            this._onScopeObjectLoaded(record);
                        },
                        scope: this
                    });
                },
                scope: this
            });
        },

        _fetchIterations: function () {
            var store = Ext.create('Rally.data.wsapi.Store', {
                model: Ext.identityFn('Iteration'),
                filters: [
                    {
                        property: 'StartDate',
                        operator: '>=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: 'EndDate',
                        operator: '<=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: this.getContext().getProjectRef()
                },
                fetch: ['Name','StartDate','EndDate'],
                limit: Infinity
            });

            store.on('load', this._onIterationsLoaded, this);
            store.load();
        },

        _areIterationsEqual: function (iteration1, iteration2) {
            return iteration1.Name === iteration2.Name &&
                   iteration1.StartDate === iteration2.StartDate &&
                   iteration1.EndDate === iteration2.EndDate;
        },

        _addIterationLines: function (chart) {
            var axis = chart.chartConfig.xAxis;
            var categories = chart.chartData.categories;
            var i, j;
            var uniqueIterations = [];
            var unique;

            axis.plotLines = [];
            axis.plotBands = [];

            for (i = 0; i < this.iterations.length; i++) {
                unique = true;
                for (j = 0; j < uniqueIterations.length; j++) {
                    if(this._areIterationsEqual(uniqueIterations[j], this.iterations[i])) {
                        unique = false;
                        break;
                    }
                }
                if(unique === true) {
                    uniqueIterations.push(this.iterations[i]);
                }
            }

            for (i = 0; i < uniqueIterations.length; i++) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[i], false));
                axis.plotBands.push(this._getPlotBand(categories, uniqueIterations[i], i % 2 !== 0));
            }

            if (uniqueIterations.length > 0) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[uniqueIterations.length - 1], true));
            }
        },
        _buildLabelText: function(iteration) {
            var labelSetting = this.getSetting("showLabels");

            var text = '';
            if (labelSetting) {
                text = iteration.Name || '';
            }
            return text;
        },

        _getPlotBand: function (categories, iteration, shouldColorize) {
            var startDate = this.dateStringToObject(iteration.StartDate);
            var endDate = this.dateStringToObject(iteration.EndDate);

            var label =   {
                    text: this._buildLabelText( iteration ),
                    align: 'center',
                    rotation: 0,
                    y: -7
            };

            return {
                color: shouldColorize ? '#F2FAFF' : '#FFFFFF',
                from: this._getNearestWorkday(categories, startDate),
                to: this._getNearestWorkday(categories, endDate),

                label: label
            };
        },

        _getNearestWorkday: function(categories, date) {
            var dateStr = Ext.Date.format(date, 'Y-m-d');
            var index = categories.indexOf(dateStr);
            if(index === -1) {
                var workdays = this._getWorkspaceConfiguredWorkdays();
                if(workdays.length < 1) {
                    return -1;
                }
                // date not in categories (probably) means it falls on a non-workday...back up to the next previous workday
                while (workdays.indexOf(Ext.Date.format(date, 'l')) === -1 && date > this._getScopeObjectStartDate()) {
                    date = Ext.Date.add(date, Ext.Date.DAY, -1);
                    dateStr = Ext.Date.format(date, 'Y-m-d');
                    index = categories.indexOf(dateStr);
                }
            }
            return index;
        },

        _getPlotLine: function (categories, iteration, lastLine) {
            var dateObj;
            var dateIndex;

            if (lastLine) {
                dateObj = this.dateStringToObject(iteration.EndDate);
            } else {
                dateObj = this.dateStringToObject(iteration.StartDate);
            }

            dateIndex = this._getNearestWorkday(categories, dateObj);

            return {
                color: '#BBBBBB',
                dashStyle: 'ShortDash',
                width: 2,
                zIndex: 3,
                value: dateIndex
            };
        },

        _addChart: function () {
            this._updateChartConfigDateFormat();
            this._updateChartConfigWorkdays();
            var chartComponentConfig = Ext.Object.merge({}, this.chartComponentConfig);

            this.add(chartComponentConfig);
            this.down('rallychart').on('snapshotsAggregated', this._onSnapshotDataReady, this);
        },

        _onSnapshotDataReady: function (chart) {
            this._updateDisplayType(chart);
            this._updateXAxis(chart);
        },

        _updateDisplayType: function (chart) {
            var series = chart.chartData.series;
            var displayType = this.getSetting('chartDisplayType');
            var i;

            for (i = 0; i < series.length; i++) {
                if (this._seriesFollowsDisplayType(series[i])) {
                    series[i].type = displayType;
                }
            }
        },

        _seriesFollowsDisplayType: function (series) {
            return series.name.indexOf('Ideal') === -1 && series.name.indexOf('Prediction') === -1;
        },

        _updateYAxis: function () {
            this._updateYAxisTitle();
            this._updateYAxisConfig();
        },

        _updateYAxisTitle: function () {
            var chartConfig = this.chartComponentConfig.chartConfig;
            chartConfig.yAxis = [
                {}
            ];
            chartConfig.yAxis[0].title = {
                text: this._getAxisTitleBasedOnAggregationType()
            };
        },

        _updateYAxisConfig: function () {
            var axis = this.chartComponentConfig.chartConfig.yAxis[0];
            axis.min = 0;
            axis.labels = {
                x: -5,
                y: 4
            };
        },

        _updateXAxis: function (chart) {
            if(this.container.dom.offsetWidth < 1000) {
                chart.chartConfig.xAxis.labels.staggerLines = 2;
            }
            chart.chartConfig.xAxis.labels.step = Math.round( chart.chartData.categories.length / 100 );
            chart.chartConfig.xAxis.tickInterval = this._configureChartTicks(chart.chartData.categories.length);
        },

        _configureChartTicks: function (days) {
            var pixelTickWidth = 125,
                appWidth = this.getWidth(),
                ticks = Math.floor(appWidth / pixelTickWidth);

            return Math.ceil(days / ticks);
        },

        _getAxisTitleBasedOnAggregationType: function () {
            var aggregationType = this.getSetting('chartAggregationType');
            if (aggregationType === 'storycount') {
                return 'Count';
            } else {
                return 'Points';
            }
        },

        _updateChartConfigDateFormat: function () {
            var self = this;

            this.chartComponentConfig.chartConfig.xAxis.labels.formatter = function () {
                return self._formatDate(self.dateStringToObject(this.value));
            };
        },

        _updateChartConfigWorkdays: function () {
            this.chartComponentConfig.calculatorConfig.workDays = this._getWorkspaceConfiguredWorkdays().split(',');
        },

        _parseRallyDateFormatToHighchartsDateFormat: function () {
            var dateFormat = this._getUserConfiguredDateFormat() || this._getWorkspaceConfiguredDateFormat();

            for (var i = 0; i < this.dateFormatters.length; i++) {
                dateFormat = dateFormat.replace(this.dateFormatters[i].key, this.dateFormatters[i].value);
            }

            return dateFormat;
        },

        _formatDate: function (date) {
            if (!this.dateFormat) {
                this.dateFormat = this._parseRallyDateFormatToHighchartsDateFormat();
            }

            return Highcharts.dateFormat(this.dateFormat, date.getTime());
        },

        _getUserConfiguredDateFormat: function () {
            return this.getContext().getUser().UserProfile.DateFormat;
        },

        _getWorkspaceConfiguredDateFormat: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
        },

        _getWorkspaceConfiguredWorkdays: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays;
        },

        _updateChartTitle: function () {
            this.chartComponentConfig.chartConfig.title = this._buildChartTitle();
        },

        _buildChartTitle: function () {
            var widthPerCharacter = 10;
            var totalCharacters = Math.floor(this.getWidth() / widthPerCharacter);
            var title = this._getDefaultTitle();
            var align = 'center';

            if (this.scopeObject) {
                title = this.scopeObject.Name;
            }

            if (totalCharacters < title.length) {
                title = title.substring(0, totalCharacters) + '...';
                align = 'left';
            }

            return {
                text: title,
                align: align,
                margin: 30
            };
        },

        _getDefaultTitle: function () {
            return Ext.String.capitalize(this._getScopeType());
        },

        _settingsInvalid: function () {
            var chartAggregationType = this.getSetting('chartAggregationType'),
                chartDisplayType = this.getSetting('chartDisplayType'),
                chartTimebox = this.getSetting('chartTimebox');

            var invalid = function (value) {
                return !value || value === 'undefined';
            };

            return invalid(chartAggregationType) || invalid(chartDisplayType) ||
                this._chartTimeboxInvalid(chartTimebox);
        },

        _chartTimeboxInvalid: function (chartTimebox) {
            if (this.context.getTimeboxScope()) {
                return false;
            }

            return !chartTimebox || chartTimebox === 'undefined';
        },

        _saveScopeType: function () {
            this.scopeType = this._getScopeType();
        },

        _getScopeType: function () {
            if (this.isOnScopedDashboard()) {
                return this._getDashboardScopeType();
            } else {
                return this._getSavedScopeType();
            }
        },

        _getDashboardScopeType: function () {
            return this.getContext().getTimeboxScope().getType();
        },

        _getSavedScopeType: function () {
            return this.getSetting('chartTimebox');
        },

        _getScopePicker: function () {
            if (this.isOnScopedDashboard()) {
                return this.getContext().getTimeboxScope();
            } else {
                return this.down('rally' + this._getScopeType() + 'combobox');
            }
        },

        _getScopeObjectStartDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseStartDate';
            } else {
                return 'StartDate';
            }
        },

        _getScopeObjectEndDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseDate';
            } else {
                return 'EndDate';
            }
        },

        _getScopeObjectStartDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseStartDate;
            } else {
                return this.scopeObject.StartDate;
            }
        },

        _getScopeObjectEndDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseDate;
            } else {
                return this.scopeObject.EndDate;
            }
        },

        _clearStoreConfig: function (storeConfig) {
            if (storeConfig.find.hasOwnProperty('Release')) {
                delete storeConfig.find.Release;
            }

            if (storeConfig.find.hasOwnProperty('Iteration')) {
                delete storeConfig.find.Iteration;
            }
        },

        _loadUserStoryModel: function() {
            Rally.data.ModelFactory.getModel({
                type: "UserStory",
                context: this._getContext(),
                success: function(model) {
                    this._getScheduleStateValues(model);
                },
                scope: this
            });
        },

        _getContext: function() {
            return {
                workspace: this.context.getWorkspaceRef(),
                project: null
            };
        },

        _getScheduleStateValues: function (model) {
            if(model) {
                model.getField("ScheduleState").getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var scheduleStates = _.collect(records, function(obj) {
                            return obj.raw;
                        });

                        var store = this._wrapRecords(scheduleStates);
                        var	values = [];
                        var acceptedSeen = false;
                        for(var i = 0; i < store.data.items.length; i++) {
                            if(store.data.items[i].data.StringValue === 'Accepted') {
                                acceptedSeen = true;
                            }
                            if(acceptedSeen) {
                                values.push(store.data.items[i].data.StringValue);
                            }
                        }

                        if(values.length > 0) {
                            this.customScheduleStates = values;
                        }
                    },
                    scope: this
                });
            }
        },

        _wrapRecords: function(records) {
            return Ext.create("Ext.data.JsonStore", {
                fields: ["_ref", "StringValue"],
                data: records
            });
        }


    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownCalculator", {
        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
        mixins: [
            "Rally.apps.charts.DateMixin"
        ],

        getDerivedFieldsOnInput: function () {
            var completedStates = this.config.completedScheduleStateNames,
                aggregationType = this.config.chartAggregationType;

            return [
                {
                    "as": "RemainingPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if(completedStates.indexOf(ss) < 0) {
                            if(aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "AcceptedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                }
            ];
        },

        getMetrics: function () {
            return [
                {
                    "field": "RemainingPoints",
                    "as": "To Do",
                    "f": "sum"
                },
                {
                    "field": "AcceptedPoints",
                    "as": "Accepted",
                    "f": "sum"
                }
            ];
        },

        getSummaryMetricsConfig: function () {
            return [
                {
                    'as': 'Scope_max',
                    'f': function(seriesData) {
                            var max = 0, i = 0;
                            for (i=0;i<seriesData.length;i++) {
                                if(seriesData[i].Accepted + seriesData[i]['To Do'] > max) {
                                    max = seriesData[i].Accepted + seriesData[i]['To Do'];
                                }
                            }
                            return max;
                         }
                }
            ];
        },

        getDerivedFieldsAfterSummary: function () {
            return  [
                {
                    "as": "Ideal",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        var max = summaryMetrics.Scope_max,
                            increments = seriesData.length - 1,
                            incrementAmount;
                        if(increments === 0) {
                            return max;
                        }
                        incrementAmount = max / increments;
                        return Math.floor(100 * (max - index * incrementAmount)) / 100;
                    },
                    "display": "line"
                },
                {
                    "as": "Prediction",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        return null;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                }
            ];
        },

        getProjectionsConfig: function () {
            var days = (this.scopeEndDate.getTime() -
                Rally.util.DateTime.fromIsoString(this.startDate).getTime()) / (24*1000*60*60);
            var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
            var timeboxEnd = Ext.Date.add(this.scopeEndDate, Ext.Date.DAY, -1);
            if(this.projectionsConfig === undefined) {
                this.projectionsConfig = {
                    doubleTimeboxEnd: doubleTimeboxEnd,
                    timeboxEnd: timeboxEnd,

                    series: [
                        {
                            "as": "Prediction",
                            "field": "To Do"
                        }
                    ],
                    continueWhile: function (point) {
                        var dt = Rally.util.DateTime.fromIsoString(point.tick);
                        var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                        return point.Prediction > 0 && dt < end;
                    }
                };
            }
            return this.projectionsConfig;
        },

        _firstNonZero: function(data) {
             var i;
             for(i=0;i<data.length;i++) {
                if(data[i] > 0) {
                    return i;
                }
             }
             return 0;
        },

        _leastSquares: function(todoValues, firstIndex, lastIndex) {
            var n = (lastIndex + 1) - firstIndex;
            var i;
            var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
            var slope, yintercept;

            //Compute sums of x, x^2, y, y^2, and xy
            for (i = firstIndex; i <= lastIndex; i++) {
                sumx  = sumx  + i;
                sumx2 = sumx2 + i * i;
                sumy  = sumy  + todoValues[i];
                sumy2 = sumy2 + todoValues[i] * todoValues[i];
                sumxy = sumxy + i * todoValues[i];
            }
            slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
            yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

            return {slope: slope, yintercept: yintercept};
        },

        runCalculation: function (snapshots) {
            var chartData = this.callParent(arguments);

            if(chartData && chartData.projections && chartData.projections.series[0].slope > 0) {
            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                var todoData = chartData.series[0].data;
                var firstTodoIndex = this._firstNonZero(todoData),
                    lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

                var results = this._leastSquares(todoData, firstTodoIndex, lastTodoIndex);

                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    chartData.series[3].data[firstTodoIndex] = ((results.slope * firstTodoIndex) + results.yintercept) + (chartData.series[3].data[lastTodoIndex] - ((results.slope * lastTodoIndex) + results.yintercept));
                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
                    if (_.max(chartData.series[3].data) > predictionCeiling) {
                        var i;
                        var maxVal = predictionCeiling;
                        for(i=0;i < chartData.series[3].data.length;i++) {
                            if(chartData.series[3].data[i] > predictionCeiling) {
                                chartData.series[3].data[i] = maxVal;
                                maxVal = null;
                            }
                        }
                    }
                }

            }

            if(new Date() < this.scopeEndDate) {
                this._recomputeIdeal(chartData, this.scopeEndDate);
            }

            return chartData;
        },

        _recomputeIdeal: function(chartData, endDate) {
             var index;
             if(chartData.categories.length < 1) {
                return;
             }
             if(this.workDays.length < 1) {
                return;
             }

             var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
             if(endDate > lastDate) {
                // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
                // (honoring "workDays").

                index = chartData.categories.length;
                var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
                while (dt < endDate) {
                    while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                        dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                    }
                    if (dt < endDate) {
                        chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                    }
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                index = chartData.categories.length - 1;
             } else {
                 // it is in "scope"...set index to the index of the last workday in scope
                 index = this._indexOfDate(chartData, endDate);
                 if(index === -1) {
                    // it's in "scope", but falls on a non-workday...back up to the previous workday
                    while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                        endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                        index = this._indexOfDate(chartData, endDate);
                    }
                 }
             }
             if(index < 0) {
                return;
             }
             // set first and last point, and let connectNulls fill in the rest
             var i;
             var seriesData = chartData.series[2].data;
             for (i=1;i<index;i++) {
                seriesData[i] = null;
             }
             seriesData[index] = 0;
        },

        _indexOfDate: function(chartData, date) {
             var dateStr = Ext.Date.format(date, 'Y-m-d');
             return chartData.categories.indexOf(dateStr);
        },

        _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
            if(chartData.series[seriesIndex].data.length > dayIndex) {
                while(++dayIndex < chartData.series[seriesIndex].data.length) {
                    chartData.series[seriesIndex].data[dayIndex] = null;
                }
            }
        },

        _projectionsSlopePositive: function (chartData) {
            if(chartData.projections && chartData.projections.series) {
                return chartData.projections.series[0].slope >= 0;
            }

            return true;
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
        extend: 'Rally.apps.charts.burndown.BurnDownApp',
        help: {
            id: 278
        },
        integrationHeaders : {
            name: 'Release Burndown'
        }
    });
}());


            Rally.launchApp('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
                name:"Release Burndown",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .burndown-app .chartControls,
.app-settings .settings-form .paddedSettingCmp {
    margin: 15px;
    border: 0px;
}

.burndown-app .chartControls .rui-triggerfield {
    display: inline-block;
}

.burndown-app .chartControls label {
    display: inline-block;
    font-size: 1.2em;
    margin: 3px 8px;
}

.portfolio-cfd-app,
.portfolio-burnup-app,
.burndown-app {
    margin: 10px;
    padding-right: 20px;
    background-color: transparent;
}

.portfolio-cfd-app .rally-help-icon,
.burndown-app .rally-help-icon,
.portfolio-burnup-app .rally-help-icon,
.chart-app .rally-help-icon {
    float: right;
}

.portfolio-cfd-app .chart,
.portfolio-burnup-app .chart {
    min-height: 2em;
}

.app-settings .settings-form .piButton {
    padding: 5px 15px 7px 15px;
    z-index: 101;
    margin-bottom: 10px;
}

.app-settings .settings-form .piDisplayField {
    background-color: #e2eff6;
    margin-left: -10px;
    min-width: 250px;
    padding: 5px 20px 3px 25px;
    z-index: 100;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}

.app-settings .settings-form .settingsLabel {
    display: block;
    font-family: NotoSansBold, Helvetica, Arial;
    font-weight: normal;
    min-height: 20px;
    text-transform: uppercase;
    width: 100px;
}

table.settings-showLabels label {
    white-space: nowrap;
    width: auto;
}
table.settings-showLabels td {
    width:130px;
}

.schedule-state-selector .@{prefix}boundlist-selected .@{prefix}form-checkbox {
    background-position: 0 -13px;
}

.statefieldvalue-boundlist-item img.stateFieldValue {
    background: transparent url('checkbox.gif');
    height: 13px;
    width: 13px;
}
.statefieldvalue-boundlist-selected img.stateFieldValue{
    background: transparent url('checkbox.gif');
    height: 13px;
    width: 13px;
    background-position-x: 0px;
    background-position-y: -13px;
}

    </style>
</head>
<body></body>
</html>
